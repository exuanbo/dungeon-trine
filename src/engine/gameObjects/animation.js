import { Sprite } from './sprite.js'
import { BoundingBox } from '../math/boundingBox.js'

/**
 * Create an empty animation with passed `width` and `height`.
 *
 * @param {number} width
 * @param {number} height
 */
export const createEmptyAnimation = (width, height) =>
  new Animation([
    new AnimationFrame({
      sprite: new Sprite(
        /* spriteSheet */ new Image(),
        /* x */ 0,
        /* y */ 0,
        width,
        height
      ),
      duration: Infinity
    })
  ])

export class AnimationFrame {
  /**
   * @param {{
   *    sprite: Sprite
   *    boundingBox?: BoundingBox
   *    duration?: number
   * }} animationFrameConfig
   */
  constructor({ sprite, boundingBox, duration = 15 }) {
    /**
     * The sprite of the animation frame.
     *
     * @public
     */
    this.sprite = sprite

    /**
     * The bounding box of the animation frame.
     *
     * {@link AnimationFrame#getBoundingBox}
     *
     * @private
     */
    this._boundingBox =
      boundingBox ||
      new BoundingBox(
        /* width */ this.sprite.width,
        /* height */ this.sprite.height
      )

    /**
     * The duration of the animation frame.
     * The unit is how many times the `nextFrame` is called.
     *
     * @public
     */
    this.duration = duration
  }

  /**
   * Get the bounding box of the frame according to the passed position.
   *
   * @public
   *
   * @param {import('../math/vector').Vector} pos
   */
  getBoundingBox(pos) {
    this._boundingBox.position.copy(pos)
    return this._boundingBox
  }
}

/**
 * Animations with their name.
 *
 * @typedef {Object<string, Animation>} AnimationsMap
 */

export class Animation {
  /**
   * Generator function to create an generator object for iterating animation frame index.
   *
   * @public
   * @static
   *
   * @param {number} frameCount
   * @param {number[]} frameDurations An array of number. Each element is the `duration` of the frame corresponding to its index.
   */
  static *createFrameIndexGenerator(frameCount, frameDurations) {
    let frameIndex = 0
    let isFrameDone = false
    let isAllFramesDone = false

    for (let i = 1; i < Infinity; i++) {
      if (i % (frameDurations[frameIndex] + 1) === 0) {
        frameIndex++
        frameIndex %= frameCount
        isFrameDone = true

        if (frameIndex === 0) {
          isAllFramesDone = true
        }
      } else {
        isFrameDone = false
        isAllFramesDone = false
      }

      /** @type {boolean} */
      const isReset = yield { frameIndex, isFrameDone, isAllFramesDone }
      if (isReset) {
        frameIndex = 0
        isFrameDone = false
        isAllFramesDone = false
        i = 0
      }
    }
  }

  /**
   * @param {AnimationFrame[]} animationFrames
   */
  constructor(animationFrames) {
    /**
     * An array of `AnimationFrame` representing the frames of the animation.
     *
     * @private
     */
    this.frames = animationFrames

    /**
     * Current frame index. Default to `0`.
     *
     * Set by `reset` and `getNextFrame`.
     *
     * @private
     */
    this.currentFrameIndex = 0

    /**
     * Animation frame index iterator for the current action.
     *
     * Generated by `Animation.createFrameIndexGenerator`.
     *
     * @private
     */
    this.frameIndexGenerator = Animation.createFrameIndexGenerator(
      /* frameCount */ this.frames.length,
      /* frameDurations */ this.frames.map(frame => frame.duration)
    )

    /**
     * {@link Animation#isCurrentFrameDone}
     *
     * @private
     */
    this._isCurrentFrameDone = false

    /**
     * {@link Animation#isAllFramesDone}
     *
     * @private
     */
    this._isAllFramesDone = false
  }

  /**
   * If the current frame has lasted enough time according to `duration` of the frame.
   *
   * Changed by `reset` and `nextFrame`.
   *
   * @public
   * @readonly
   */
  get isCurrentFrameDone() {
    return this._isCurrentFrameDone
  }

  /**
   * If the current frame index is set back to `0`.
   *
   * Changed by `reset` and `nextFrame`.
   *
   * @public
   * @readonly
   */
  get isAllFramesDone() {
    return this._isAllFramesDone
  }

  /**
   * Get current frame according to `currentFrameIndex`.
   *
   * @public
   */
  getCurrentFrame() {
    return this.frames[this.currentFrameIndex]
  }

  /**
   * Change `currentFrameIndex` to the next frame index generated by `frameIndexGenerator`.
   *
   * @public
   */
  nextFrame() {
    const { frameIndex, isFrameDone, isAllFramesDone } =
      /**
       * @type {{
       *    frameIndex: number,
       *    isFrameDone: boolean
       *    isAllFramesDone: boolean
       * }}
       */
      (this.frameIndexGenerator.next().value)

    if (isFrameDone) {
      this.currentFrameIndex = frameIndex
    }
    this._isCurrentFrameDone = isFrameDone
    this._isAllFramesDone = isAllFramesDone
  }

  /**
   * Reset `currentFrameIndex`, `frameIndexGenerator` and `isCurrentFrameDone`.
   *
   * @public
   */
  reset() {
    this.currentFrameIndex = 0
    this.frameIndexGenerator.next(/* isReset */ true)
    this._isCurrentFrameDone = false
    this._isAllFramesDone = false
  }
}
