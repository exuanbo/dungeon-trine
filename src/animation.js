import { Sprite } from './sprite.js'

/**
 * Animations with their name.
 *
 * @typedef {Object<string, Animation>} AnimationsMap
 */

/**
 * Create `<animationName, Animation>` map from provided entries.
 *
 * @param {HTMLImageElement|HTMLCanvasElement} spriteSheet
 * @param {Array<[
 *    animationName: string,
 *    sx: number,
 *    sy: number,
 *    width: number,
 *    height: number,
 *    frameCount: number,
 *    frameDuration?: number
 * ]>} animationEntries
 */
export const makeAnimationsMap = (spriteSheet, animationEntries) => {
  /** @type {AnimationsMap} */
  const animationsMap = {}

  animationEntries.forEach(
    ([animationName, sx, sy, width, height, frameCount, frameDuration = 9]) => {
      const animationFrames = []

      for (let i = 0; i < frameCount; i++) {
        animationFrames.push(
          new Sprite(spriteSheet, sx + i * width, sy, width, height)
        )
      }

      animationsMap[animationName] = new Animation(
        animationFrames,
        frameDuration
      )
    }
  )

  return animationsMap
}

export class Animation {
  /**
   * Generator function to create an iterator for animation frame index.
   *
   * @public
   * @static
   *
   * @param {number} frameCount
   * @param {number} frameDuration
   */
  static *makeFrameIndexIterator(frameCount, frameDuration) {
    let frameIndex = 0
    let isFrameDone = false

    for (let i = 1; i < Infinity; i++) {
      if (i % frameDuration === 0) {
        frameIndex++
        frameIndex %= frameCount
        isFrameDone = true
      } else {
        isFrameDone = false
      }

      yield { frameIndex, isFrameDone }
    }
  }

  /**
   * @param {Sprite[]} frames
   * @param {number} frameDuration
   */
  constructor(frames, frameDuration) {
    /**
     * Current frame index.
     *
     * Set by `reset` and `getNextFrame`.
     *
     * @private
     *
     * @type {number}
     */
    this.currentFrameIndex = undefined

    /**
     * Animation frame index iterator for the current action.
     *
     * Generated by `Animation.makeFrameIndexIterator` and set by `reset`.
     *
     * @private
     *
     * @generator
     */
    this.frameIndexIterator = undefined

    /**
     * {@link Animation#isCurrentFrameDone}
     *
     * @private
     *
     * @type {boolean}
     */
    this._isCurrentFrameDone = undefined

    /**
     * An array of sprites representing the frames of the animation.
     *
     * @private
     */
    this.frames = frames

    /**
     * Duration per frame. The unit is the rendered time.
     *
     * @private
     */
    this.frameDuration = frameDuration

    this.reset()
  }

  /**
   * If the current frame has lasted enough time according to `frameDuration`.
   *
   * Changed by `reset` and `getNextFrame`.
   *
   * @public
   * @readonly
   */
  get isCurrentFrameDone() {
    return this._isCurrentFrameDone
  }

  /**
   * Reset `currentFrameIndex`, `frameIndexIterator` and `isCurrentFrameDone`.
   *
   * @public
   */
  reset() {
    this.currentFrameIndex = 0
    this.frameIndexIterator = Animation.makeFrameIndexIterator(
      this.frames.length,
      this.frameDuration
    )
    this._isCurrentFrameDone = false
  }

  /**
   * Get current frame according to `currentFrameIndex`.
   *
   * @public
   */
  getCurrentFrame() {
    return this.frames[this.currentFrameIndex]
  }

  /**
   * Get next animation frame according to the next frame index returned by `frameIndexIterator`.
   *
   * @public
   */
  getNextFrame() {
    const { frameIndex, isFrameDone } = this.frameIndexIterator.next().value

    if (isFrameDone) {
      this.currentFrameIndex = frameIndex
    }
    this._isCurrentFrameDone = isFrameDone

    return this.getCurrentFrame()
  }
}
