import { Sprite } from './sprite.js'
import { vector } from './vector.js'
import g, { CANVAS_SIZE, TILE_SIZE } from './globals.js'

class Charactor {
  /**
   * @param {{
   *    framesMap: import('./sprite').FramesMap,
   *    position: import('./vector').Vector,
   *    ctx: CanvasRenderingContext2D
   * }}
   */
  constructor({ framesMap, position, ctx }) {
    /**
     * The actual rendered times. Used for controlling actions interval.
     *
     * Increased by `render`.
     *
     * @protected
     */
    this.actualFramesPast = 0

    /**
     * Sprite Frames for the current action.
     *
     * Set by `setCurrentFrames`.
     *
     * @private
     *
     * @type {import('./sprite').Frames}
     */
    this.currentFrames = undefined

    /**
     * Current sprite index in the frames.
     *
     * Set by `setCurrentFrames` and `getNextFrameSprite`.
     *
     * @private
     *
     * @type {number}
     */
    this.currentFrameIndex = undefined

    /**
     * If the current sprite frame has lasted enough time according to `Frames.duration`.
     *
     * If true, `currentFrameIndex` would change at next render.
     *
     * Set by `setCurrentFrames` and `getNextFrameSprite`.
     *
     * @private
     *
     * @type {boolean}
     */
    this.isCurrentFrameDone = undefined

    /**
     * Sprite frame index iterator for the current action.
     *
     * Generated by `Sprite.makeFrameIndexIterator`. Set by `setCurrentFrames`.
     *
     * @private
     *
     * @generator
     */
    this.frameIndexIterator = undefined

    /**
     * The actual action name
     *
     * @private
     */
    this._action = 'idle'

    /**
     * If the charactor will stop to `idle` at next render.
     *
     * Set back to false in `stop`.
     *
     * @public
     */
    this.willStop = false

    /**
     * Moving directions.
     *
     * @public
     */
    this.directions = { up: false, right: false, down: false, left: false }

    /**
     * Default moving speed. Pixels per render.
     *
     * @private
     */
    this.speed = 2

    /**
     * Which side is the charactor facing.
     *
     * Chanaged by `move`.
     *
     * @private
     */
    this.face = 'right'

    /**
     * The provided frames map.
     *
     * @private
     */
    this.framesMap = framesMap

    this.setCurrentFrames()

    /**
     * Current position in the layer. Default value is set by argument.
     *
     * @private
     */
    this.position = position

    /**
     * Canvas context for rendering.
     *
     * @private
     */
    this.ctx = ctx
  }

  /**
   * Action getter for `_action`.
   *
   * @protected
   */
  get action() {
    return this._action
  }

  /**
   * Set sprite frames according to current action.
   *
   * Should only be called by `setAction`
   *
   * @private
   */
  setCurrentFrames() {
    this.currentFrames = this.framesMap[this.action]
    this.currentFrameIndex = 0
    this.isCurrentFrameDone = false
    this.frameIndexIterator = Sprite.makeFrameIndexIterator(
      this.currentFrames.sprites.length,
      this.currentFrames.duration
    )
  }

  /**
   * Get current frame sprite according to `currentFrameIndex`.
   *
   * @private
   */
  getCurrentFrameSprite() {
    return this.currentFrames.sprites[this.currentFrameIndex]
  }

  /**
   * Get next frame sprite according to the next frame index generated by `frameIndexIterator`.
   *
   * @private
   */
  getNextFrameSprite() {
    const { frameIndex, isFrameDone } = this.frameIndexIterator.next().value

    if (isFrameDone) {
      this.currentFrameIndex = frameIndex
    }
    this.isCurrentFrameDone = isFrameDone

    return this.getCurrentFrameSprite()
  }

  /**
   * Action setter.
   *
   * Set the given action if the charactor has no other actions.
   *
   * `idle` will be interrupted and `attack` will be prioritized.
   *
   * Return whether the action has been successfully set.
   *
   * @protected
   *
   * @param {string} actionName
   * @returns {boolean} isSet
   */
  setAction(actionName) {
    if (
      !this.isCurrentFrameDone &&
      this.action !== 'idle' &&
      actionName !== 'attack'
    ) {
      return false
    }

    this._action = actionName
    this.setCurrentFrames()
    return true
  }

  /**
   * If the charactor will move at next render.
   *
   * Decide by checking whether exists true value in `directions`.
   *
   * @private
   */
  willMove() {
    for (const directionName in this.directions) {
      if (this.directions[directionName]) {
        return true
      }
    }

    return false
  }

  /**
   * Move action.
   *
   * Change `face` if turing direction from left to right or from right to left.
   *
   * Stop when will collide with wall.
   *
   * @private
   */
  move() {
    if (this.action !== 'move') {
      const isSet = this.setAction('move')
      if (!isSet) {
        return
      }
    }

    const originalPosition = { ...this.position }

    if (this.directions.up) {
      this.position.y -= this.speed
    }
    if (this.directions.right) {
      this.position.x += this.speed
      if (!this.directions.left) {
        this.face = 'right'
      }
    }
    if (this.directions.down) {
      this.position.y += this.speed
    }
    if (this.directions.left) {
      this.position.x -= this.speed
      if (!this.directions.right) {
        this.face = 'left'
      }
    }

    const currentFrameSprite = this.getCurrentFrameSprite()

    if (
      this.position.x <= TILE_SIZE ||
      this.position.x + currentFrameSprite.width >= CANVAS_SIZE - TILE_SIZE ||
      this.position.y <= TILE_SIZE ||
      this.position.y + currentFrameSprite.height >= CANVAS_SIZE - TILE_SIZE - 4
    ) {
      this.position = originalPosition
    }
  }

  /**
   * Stop action.
   *
   * Change `willStop` back to `false` if successfully set action to `idle`.
   *
   * @protected
   */
  stop() {
    if (this.action !== 'idle') {
      const isSet = this.setAction('idle')
      if (!isSet) {
        return
      }
    }
    this.willStop = false
  }

  /**
   * Perform actions if the predicates are fulfilled.
   *
   * @protected
   */
  act() {
    if (this.willMove()) {
      this.move()
    }
  }

  /**
   * Render the charactor to the current layer.
   *
   * Increase `actualFramesPast` by 1 at the end.
   *
   * @protected
   */
  render() {
    this.actualFramesPast++

    const currentFrameSprite = this.getCurrentFrameSprite()

    this.ctx.clearRect(
      this.position.x,
      this.position.y,
      currentFrameSprite.width,
      currentFrameSprite.height
    )

    if (this.willStop) {
      this.stop()
    } else {
      this.act()
    }

    const nextFrameSprite = this.getNextFrameSprite()

    const drawImage = (dx, dy) => {
      this.ctx.drawImage(
        currentFrameSprite.spriteSheet,
        nextFrameSprite.position.x,
        nextFrameSprite.position.y,
        nextFrameSprite.width,
        nextFrameSprite.height,
        dx,
        dy,
        nextFrameSprite.width,
        nextFrameSprite.height
      )
    }

    if (this.face === 'left') {
      /**
       * {@link https://stackoverflow.com/a/37388113/13346012
       * |How to flip images horizontally with HTML5}
       */
      this.ctx.save()
      this.ctx.translate(
        this.position.x + nextFrameSprite.width / 2,
        this.position.y + nextFrameSprite.height / 2
      )
      this.ctx.scale(-1, 1)
      drawImage(-nextFrameSprite.width / 2, -nextFrameSprite.height / 2)
      this.ctx.restore()
    } else {
      drawImage(this.position.x, this.position.y)
    }
  }
}

/**
 * User controlled charactor.
 */
export class Player extends Charactor {
  /**
   * @param {CanvasRenderingContext2D} ctx
   */
  constructor(ctx) {
    const spriteSheet = g.assets.image.dungeonTileSet
    const framesMap = Sprite.makeFramesMap(spriteSheet, [
      ['idle', 128, 100, 16, 28, 4],
      ['move', 192, 100, 16, 28, 4],
      ['attack', 256, 100, 16, 28, 1, 12]
    ])

    const position = vector(CANVAS_SIZE / 2 - TILE_SIZE / 2)

    super({ framesMap, position, ctx })

    /**
     * If the charactor will attack at next render.
     *
     * @public
     */
    this.willAttack = false

    /**
     * If the charactor has already attacked once.
     *
     * `attack` sets it to `true` and `stop` sets it back to `false`.
     *
     * @private
     */
    this.hasAttacked = false

    /**
     * Default attack interval. Use `actualFramesPast`.
     *
     * @private
     */
    this.attackInterval = 36

    /**
     * Last time the charactor attacked. Use `actualFramesPast`.
     *
     * @private
     *
     * @type {number}
     */
    this.lastAttack = undefined
  }

  /**
   * Attack action.
   *
   * Return in advance if the charactor has already attacted before `stop`
   * or the difference of two attack times is less than `attackInterval`.
   *
   * Change `hasAttacked` to `true`.
   *
   * @protected
   */
  attack() {
    if (this.hasAttacked) {
      if (!this.willStop) {
        this.willStop = true
      }
      return
    }

    if (this.actualFramesPast - this.lastAttack < this.attackInterval) {
      return
    }

    this.setAction('attack')
    this.hasAttacked = true
    this.lastAttack = this.actualFramesPast
  }

  /**
   * Override `Charactor.stop`.
   *
   * Change `hasAttacked` back to false.
   *
   * @override
   * @protected
   */
  stop() {
    super.stop()
    this.hasAttacked = false
  }

  /**
   * Override `Charactor.act`.
   *
   * Perform actions if the predicates are fulfilled.
   *
   * @override
   * @protected
   */
  act() {
    if (this.willAttack) {
      this.attack()
    }
    super.act()
  }
}
